#define _CRT_SECURE_NO_WARNINGS								// scanf関数を使用するため定義
#define _USE_MATH_DEFINES									// 円周率 PI = 3.14159...を"M_PI"として使用するための定義
#define GNUPLOT "C:/gnuplot/bin/gnuplot.exe -persist"		// Graph software ("GNUPLOT") の .exe ファイルの Address を定義, および "-persist" は gnuplot が直ぐに閉じないようにするため

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <complex.h>


//============================================================================================================================================================================
// Photonic crystal (Si rod) waveguideにおける電磁波伝播_PML吸収境界条件を用いたFDTD法 (xy平面を伝搬する電磁波におけるTE modeの電場を求める) "pulse波(2次元) Gaussian Modulated Continuous Wave" ※(媒質(Si rod)/真空)
//============================================================================================================================================================================


int main(void)
{
	//========================================================================================================================================================================
	//(1). 物理定数の設定

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 真空における物性値
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	double c0 = 2.99792458 * pow(10.0, 8.0);																// 真空における光の速さ [m/sec]
	double l0 = 1.5 * pow(10.0, -6.0);																		// 真空における光の波長 [m]
	double f0 = c0 / l0;																					// 真空における光の周波数 [Hz]
	double k0 = (2.0 * M_PI) / l0;																			// 真空における波数 [rad/m]
	double w0 = 2.0 * M_PI * f0;																			// 真空における角周波数 [rad/sec]
	double PerE0 = 8.854187816 * pow(10.0, -12.0);															// 真空の誘電率 [F/m]
	double PerM0 = 4.0 * M_PI * pow(10.0, -7.0);															// 真空の透磁率 1.2566370614 * pow(10.0, -6.0) [H/m (= N/A^2)]
	double Z0 = sqrt(PerM0 / PerE0);																		// 真空における波動Impedance


	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 媒質(Si)における物性値
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//double nSi = 3.4835;																					// 媒質(Si)の屈折率(波長1.5umにおけるSi薄膜の屈折率)
	double nSi = 3.46;																						// 媒質(Si)の屈折率(波長1.5umにおけるSi薄膜の屈折率)
	double KappaSi = 2.1833 * pow(10.0, -9.0);																// 媒質(Si)の消衰係数(波長1.5umにおけるSi薄膜の消衰係数)
	double cSi = c0 / nSi;																					// 媒質(Si)中における光の速さ [m/sec]
	double lSi = cSi / f0;																					// 媒質(Si)中における光の波長(linear opticsの場合で考える) [m] ※linear opticsの場合: 媒質中も真空中も周波数は等しい(周波数は媒質中でも不変), nonlinear opticsの場合: 非線形現象により波長が変化する
	double kSi = (2.0 * M_PI) / lSi;																		// 媒質(Si)における波数 [rad/m]
	double PerESi = 11.8 * PerE0;																			// 媒質(Si)の誘電率 [F/m] ※比誘電率11.8で計算
	double PerMSi = 1.0 * PerM0;																			// 媒質(Si)の透磁率 [H/m] ※非磁性体として比透磁率1.0で計算
	double ZSi = sqrt(PerMSi / PerESi);																		// 媒質(Si)における波動Impedance
	double SigmaSi = 1.602176634 * pow(10.0, -19.0) * pow(10.0, 20.0) * (1400.0 * pow(10.0, -4.0));			// 媒質(Si)の導電率 [S/m] ※n型半導体として (電気素量 [C]) * (電子濃度 [m-3]) * (電子移動度 [m2/Vsec])

	_Dcomplex NSi = _Cbuild(nSi, KappaSi);																	// 媒質(Si)の複素屈折率 = (屈折率) + (消衰係数) * 虚数i
	_Dcomplex kSi_complex = _Cmulcr(NSi, w0 / cSi);															// 媒質(Si)における波数 = (媒質(Si)の複素屈折率) * (周波数) / (媒質(Si)中における光の速さ)


	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 媒質(SiO2)における物性値
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	double nSiOx = 1.4603;																					// 媒質(SiO2)の屈折率(波長1.5umにおけるSiO2薄膜の屈折率)
	double KappaSiOx = 2.9107 * pow(10.0, -7.0);															// 媒質(SiO2)の消衰係数(波長1.5umにおけるSiO2薄膜の消衰係数)
	double cSiOx = c0 / nSiOx;																				// 媒質(SiO2)中における光の速さ [m/sec]
	double lSiOx = cSiOx / f0;																				// 媒質(SiO2)中における光の波長(linear opticsの場合で考える) [m] ※linear opticsの場合: 媒質中も真空中も周波数は等しい(周波数は媒質中でも不変), nonlinear opticsの場合: 非線形現象により波長が変化する
	double kSiOx = (2.0 * M_PI) / lSiOx;																	// 媒質(SiO2)における波数 [rad/m]
	double dSiOx = l0 * 1.0;																				// 媒質(SiO2)の領域 [m] ※1次元
	double PerESiOx = 3.8 * PerE0;																			// 媒質(SiO2)の誘電率 [F/m] ※比誘電率3.8で計算
	double PerMSiOx = 1.0 * PerM0;																			// 媒質(SiO2)の透磁率 [H/m] ※非磁性体として比透磁率1.0で計算
	double ZSiOx = sqrt(PerMSiOx / PerESiOx);																// 媒質(SiO2)における波動Impedance
	double SigmaSiOx = 0.0;																					// 媒質(SiO2)の導電率 [S/m] ※n型半導体として (電気素量 [C]) * (電子濃度 [m-3]) * (電子移動度 [m2/Vsec])

	_Dcomplex NSiOx = _Cbuild(nSiOx, KappaSiOx);															// 媒質(SiO2)の複素屈折率 = (屈折率) + (消衰係数) * 虚数i
	_Dcomplex kSiOx_complex = _Cmulcr(NSiOx, w0 / cSiOx);													// 媒質(SiO2)における波数 = (媒質(SiO2)の複素屈折率) * (周波数) / (媒質(SiO2)中における光の速さ)


	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// FDTD法における時間差分用 および 空間差分用の設定値
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	int i, j;																								// 空間差分用の空間step数(解析領域分割数 = cell数)に対するcounter変数
	int t;																									// 時間差分用の時間step数に対するcounter変数

	//double x = 10.0 * pow(10.0, -6.0);																		// x軸方向における解析領域の範囲 [m] ※xy平面の2次元
	//double x = 7.0 * pow(10.0, -6.0);																		// x軸方向における解析領域の範囲 [m] ※xy平面の2次元
	//double y = 7.0 * pow(10.0, -6.0);																		// y軸方向における解析領域の範囲 [m] ※xy平面の2次元

	//int Nx = 1000;																							// x軸方向における空間差分用の空間step数
	//int Nx = 700;																							// x軸方向における空間差分用の空間step数
	//int Ny = 700;																							// y軸方向における空間差分用の空間step数
	//int Nt = 3335;																							// 時間差分用の時間step数
	//int Nt = 2335;																							// 時間差分用の時間step数


	//double x = 9.4 * pow(10.0, -6.0);																		// x軸方向における解析領域の範囲 [m] ※xy平面の2次元
	double x = 6.4 * pow(10.0, -6.0);																		// x軸方向における解析領域の範囲 [m] ※xy平面の2次元
	double y = 6.4 * pow(10.0, -6.0);																		// y軸方向における解析領域の範囲 [m] ※xy平面の2次元

	//int Nx = 940;																							// x軸方向における空間差分用の空間step数
	int Nx = 640;																							// x軸方向における空間差分用の空間step数
	int Ny = 640;																							// y軸方向における空間差分用の空間step数
	//int Nt = 3135;																							// 時間差分用の時間step数
	int Nt = 2135;																							// 時間差分用の時間step数

	double dx = x / Nx;																						// x軸方向におけるcellの幅 [m]
	double dy = y / Ny;																						// y軸方向におけるcellの幅 [m]
	double dt = x / (c0 * Nt);																				// 時間差分における単位step時間 [sec]




	//========================================================================================================================================================================
	//(2). 媒質による誘電率分布と透磁率分布の設定 および 計算

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 誘電率分布 および 透磁率分布の設定
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	double** PerE = NULL;																					// 解析領域における誘電率分布を設定するための変数
	double** PerM = NULL;																					// 解析領域における透磁率分布を設定するための変数
	PerE = (double**)malloc(sizeof(double*) * (Nx + 1));													// 解析領域における誘電率分布用ポインタ変数の1つ目の配列要素数を設定(x軸方向成分)
	PerM = (double**)malloc(sizeof(double*) * (Nx + 1));													// 解析領域における透磁率分布用ポインタ変数の1つ目の配列要素数を設定(x軸方向成分)
	if (PerE == NULL)		exit(0);
	if (PerM == NULL)		exit(0);

	for (int i = 0; i < Nx + 1; i++)
	{
		PerE[i] = (double*)malloc(sizeof(double) * (Ny + 1));												// 解析領域における誘電率分布用ポインタ変数の2つ目の配列要素数を設定(y軸方向成分)
		PerM[i] = (double*)malloc(sizeof(double) * (Ny + 1));												// 解析領域における透磁率分布用ポインタ変数の2つ目の配列要素数を設定(y軸方向成分)
	}
	if (PerE == NULL)		exit(0);
	if (PerM == NULL)		exit(0);


	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// "n * m"行列のPhotonic Crystal (PhC)におけるPhC-Waveguideを表現するための変数設定
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	int mx;																									// "n * m"行列における"n"行のための変数
	int my;																									// "n * m"行列における"m"列のための変数
	int Nmx = 9;																							// "n * m"行列における行数の設定
	int Nmy = 9;																							// "n * m"行列における列数の設定

	double n_r2 = 1.92;																						// 特定の媒質における屈折率(関連して誘電率も)
	double PerM_r2 = 1.0 * PerM0;																			// 特定の媒質の透磁率 [H/m] ※非磁性体として比透磁率1.0で計算
	double PerE_r2 = ((PerE0 * PerM0) / PerM_r2) * pow(n_r2, 2.0);											// 特定の媒質の誘電率 [F/m]

	double** r = NULL;																						// Micro-RingあるいはCurveの光行路(光導波路)を表現するためのradius設定用のポインタ変数(2次元)
	r = (double**)malloc(sizeof(double*) * (Nx + 1));														// Micro-RingあるいはCurveの光行路(光導波路)を表現するためのradius設定用のポインタ変数(2次元)における1つ目の配列要素数を設定(x軸方向成分)
	if (r == NULL)			exit(0);

	for (int i = 0; i < Nx + 1; i++)
	{
		r[i] = (double*)malloc(sizeof(double) * (Ny + 1));													// Micro-RingあるいはCurveの光行路(光導波路)を表現するためのradius設定用のポインタ変数(2次元)における1つ目の配列要素数を設定(y軸方向成分)
	}
	if (r == NULL)			exit(0);


	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 誘電率分布 および 透磁率分布の配置座標(存在位置)の設定
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	for (int i = 0; i < Nx + 1; i++)																		// 下地媒質の誘電率および透磁率を解析領域の全座標に設定(配置) ※全面(全座標)が下地媒質の誘電率・透磁率で設定されるが, 下記codeで誘電体媒質の存在位置に誘電率・透磁率を更新(上書き)させる
	{
		for (int j = 0; j < Ny + 1; j++)
		{
			PerE[i][j] = PerE0;
			PerM[i][j] = PerM0;
		}
	}

	for (mx = 0; mx < Nmx; mx++)																			// 誘電体媒質を配置(下地媒質から誘電体媒質の存在位置について誘電率および透磁率を更新(上書き))
	{
		for (my = 0; my < Nmy; my++)
		{
			for (int i = 0; i < Nx + 1; i++)
			{
				for (int j = 0; j < Ny + 1; j++)
				{
					//r[i][j] = sqrt(pow((i - 110) * dx - mx * 0.6 * pow(10.0, -6.0), 2.0) + pow((j - 110) * dy - my * 0.6 * pow(10.0, -6.0), 2.0));
					r[i][j] = sqrt(pow((i - 80) * dx - mx * 0.6 * pow(10.0, -6.0), 2.0) + pow((j - 80) * dy - my * 0.6 * pow(10.0, -6.0), 2.0));

					// ■ NOT gate
					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					// 解析領域範囲内において n * m 行列 (matrix) で "半径 = r[i][j]" の誘電体媒質が存在する場合の誘電体分布設定のための条件分岐(1_withoutWG)
					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					//if (r[i][j] <= 0.12 * pow(10.0, -6.0))
					//{
					//	PerE[i][j] = PerESi;
					//	PerM[i][j] = PerMSi;
					//}


					// ■ NOT gate
					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					// 解析領域範囲内において n * m 行列 (matrix) で "半径 = r[i][j]" の誘電体媒質が存在するが, 一部分が defect(誘電体媒質が存在しない状態)で waveguide 状態の場合における誘電体分布設定のための条件分岐(2_withWG)
					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					//if (r[i][j] <= 0.12 * pow(10.0, -6.0))
					//{
					//	PerE[i][j] = PerE_r2;
					//	PerM[i][j] = PerM_r2;

					//	if (my == 4 && r[i][j] <= 0.12 * pow(10.0, -6.0))
					//	{
					//		PerE[i][j] = PerE0;
					//		PerM[i][j] = PerM0;
					//	}

					//	else if (mx == 4 && my <= 4 && r[i][j] <= 0.12 * pow(10.0, -6.0))
					//	{
					//		PerE[i][j] = PerE0;
					//		PerM[i][j] = PerM0;
					//	}
					//}


					// ■ NOT gate
					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					// 解析領域範囲内において n * m 行列 (matrix) で "半径 = r[i][j]" の誘電体媒質が存在するが, 一部分が defect(誘電体媒質が存在しない状態)で waveguide 状態および誘電率の異なる媒質 (屈折率 1.92) が存在する場合における誘電体分布設定のための条件分岐(3_withWG)
					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					if (r[i][j] < 0.121 * pow(10.0, -6.0))
					{
						PerE[i][j] = PerESi;
						PerM[i][j] = PerMSi;

						if (my == 4 && r[i][j] < 0.121 * pow(10.0, -6.0))
						{
							PerE[i][j] = PerE0;
							PerM[i][j] = PerM0;
						}

						else if (mx == 4 && my < 4 && r[i][j] < 0.121 * pow(10.0, -6.0))
						{
							PerE[i][j] = PerE0;
							PerM[i][j] = PerM0;
						}

						else if (mx == 5 && my == 3 && r[i][j] < 0.121 * pow(10.0, -6.0))
						{
							PerE[i][j] = PerE_r2;
							PerM[i][j] = PerM_r2;
						}
					}


					// ■ NOR & XNOR & NAND gate
					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					// 解析領域範囲内において n * m 行列 (matrix) で "半径 = r[i][j]" の誘電体媒質が存在する場合の誘電体分布設定のための条件分岐(1_withoutWG)
					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					//if (r[i][j] <= 0.12 * pow(10.0, -6.0))
					//{
					//	PerE[i][j] = PerE_r2;
					//	PerM[i][j] = PerM_r2;
					//}


					// ■ NOR & XNOR & NAND gate
					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					// 解析領域範囲内において n * m 行列 (matrix) で "半径 = r[i][j]" の誘電体媒質が存在するが, 一部分が defect(誘電体媒質が存在しない状態)で waveguide 状態の場合における誘電体分布設定のための条件分岐(2_withWG)
					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					//if (r[i][j] <= 0.12 * pow(10.0, -6.0))
					//{
					//	PerE[i][j] = PerE_r2;
					//	PerM[i][j] = PerM_r2;

					//	if (my == 4 && r[i][j] <= 0.12 * pow(10.0, -6.0))
					//	{
					//		PerE[i][j] = PerE0;
					//		PerM[i][j] = PerM0;
					//	}

					//	else if (mx == 4 && my < 4 && r[i][j] <= 0.12 * pow(10.0, -6.0))
					//	{
					//		PerE[i][j] = PerE0;
					//		PerM[i][j] = PerM0;
					//	}
					//	
					//	else if (mx == 9 && my < 4 && r[i][j] <= 0.12 * pow(10.0, -6.0))
					//	{
					//		PerE[i][j] = PerE0;
					//		PerM[i][j] = PerM0;
					//	}
					//}


					// ■ NOR & XNOR & NAND gate
					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					// 解析領域範囲内において n * m 行列 (matrix) で "半径 = r[i][j]" の誘電体媒質が存在するが, 一部分が defect(誘電体媒質が存在しない状態)で waveguide 状態および誘電率の異なる媒質 (屈折率 1.92) が存在する場合における誘電体分布設定のための条件分岐(3_withWG)
					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					//if (r[i][j] <= 0.12 * pow(10.0, -6.0))
					//{
					//	PerE[i][j] = PerE_r2;
					//	PerM[i][j] = PerM_r2;

					//	if (my == 4 && r[i][j] <= 0.12 * pow(10.0, -6.0))
					//	{
					//		PerE[i][j] = PerE0;
					//		PerM[i][j] = PerM0;
					//	}

					//	else if (mx == 4 && my < 4 && r[i][j] <= 0.12 * pow(10.0, -6.0))
					//	{
					//		PerE[i][j] = PerE0;
					//		PerM[i][j] = PerM0;
					//	}

					//	else if (mx == 9 && my < 4 && r[i][j] <= 0.12 * pow(10.0, -6.0))
					//	{
					//		PerE[i][j] = PerE0;
					//		PerM[i][j] = PerM0;
					//	}

					//	else if (mx == 5 && my == 3 && r[i][j] <= 0.12 * pow(10.0, -6.0))
					//	{
					//		PerE[i][j] = PerE_r2;
					//		PerM[i][j] = PerM_r2;
					//	}

					//	else if (mx == 10 && my == 3 && r[i][j] <= 0.12 * pow(10.0, -6.0))
					//	{
					//		PerE[i][j] = PerE_r2;
					//		PerM[i][j] = PerM_r2;
					//	}
					//}

				}
			}
		}
	}




	//========================================================================================================================================================================
	//(3). PML吸収境界条件適用のための設定 および PML領域における導電率と(仮想的な)導磁率の計算

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// PML層(PML領域)の設定
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	int Lx_PML = 50;																						// x軸におけるPML吸収境界条件用のPML層数(片側)
	int Ly_PML = 50;																						// x軸におけるPML吸収境界条件用のPML層数(片側)
	float M = 5.0;																							// PML吸収境界条件における分布の次数
	double dx_PML = dx * Lx_PML;																			// x軸における片側PML厚さ [m]
	double dy_PML = dy * Ly_PML;																			// y軸における片側PML厚さ [m]
	double R_Coe = pow(10.0, -2.0);																			// 反射係数"R"
	//double sigmaX_max = -((M + 1.0) / (2.0 * ZSi * dx)) * log(R_Coe);										// PML吸収境界条件における最大導電率用の変数(x軸方向) ※PML領域は左側も右側も真空と仮定
	//double sigmaY_max = -((M + 1.0) / (2.0 * ZSi * dy)) * log(R_Coe);										// PML吸収境界条件における最大導電率用の変数(y軸方向) ※PML領域は左側も右側も真空と仮定
	double sigmaX_max = -((M + 1.0) / (2.0 * Z0 * dx)) * log(R_Coe);										// PML吸収境界条件における最大導電率用の変数(x軸方向) ※PML領域は左側も右側も真空と仮定
	double sigmaY_max = -((M + 1.0) / (2.0 * Z0 * dy)) * log(R_Coe);										// PML吸収境界条件における最大導電率用の変数(y軸方向) ※PML領域は左側も右側も真空と仮定

	double* sigmaE_x = NULL;																				// PML吸収境界条件におけるx軸方向のPML層(PML領域)の導電率用ポインタ変数
	double* sigmaE_y = NULL;																				// PML吸収境界条件におけるy軸方向のPML層(PML領域)の導電率用ポインタ変数
	double* sigmaM_x = NULL;																				// PML吸収境界条件におけるx軸方向のPML層(PML領域)の仮想的な導磁率用ポインタ変数
	double* sigmaM_y = NULL;																				// PML吸収境界条件におけるy軸方向のPML層(PML領域)の仮想的な導磁率用ポインタ変数
	sigmaE_x = (double*)malloc(sizeof(double) * (Nx + 1));													// PML吸収境界条件におけるx軸方向の導電率用ポインタ変数の1つ目の配列要素数を設定
	sigmaE_y = (double*)malloc(sizeof(double) * (Ny + 1));													// PML吸収境界条件におけるy軸方向の導電率用ポインタ変数の1つ目の配列要素数を設定
	sigmaM_x = (double*)malloc(sizeof(double) * (Nx + 1));													// PML吸収境界条件におけるx軸方向の仮想的な導磁率用ポインタ変数の1つ目の配列要素数を設定
	sigmaM_y = (double*)malloc(sizeof(double) * (Ny + 1));													// PML吸収境界条件におけるy軸方向の仮想的な導磁率用ポインタ変数の1つ目の配列要素数を設定
	if (sigmaE_x == NULL)	exit(0);
	if (sigmaE_y == NULL)	exit(0);
	if (sigmaM_x == NULL)	exit(0);
	if (sigmaM_y == NULL)	exit(0);


	for (int i = 0; i < Nx + 1; i++)																		// x軸方向におけるPML領域の導電率 および 仮想的な導磁率を設定
	{
		if (i < Lx_PML)
		{
			sigmaE_x[i] = sigmaX_max * pow(1.0 - (i * dx) / dx_PML, M);										// PML領域左側における導電率計算(解析領域の左側)
			//sigmaM_x[i] = sigmaE_x[i] * (PerMSi / PerESi);													// PML領域左側における仮想的な導磁率計算(解析領域の左側) ※Impedance matching条件から計算
			sigmaM_x[i] = sigmaE_x[i] * (PerM0 / PerE0);													// PML領域左側における仮想的な導磁率計算(解析領域の左側) ※Impedance matching条件から計算
		}

		else if (i > Nx - Lx_PML)
		{
			sigmaE_x[i] = sigmaX_max * pow((i * dx - (Nx - Lx_PML) * dx) / dx_PML, M);						// PML領域右側における導電率計算(解析領域の右側)
			//sigmaM_x[i] = sigmaE_x[i] * (PerMSi / PerESi);													// PML領域右側における仮想的な導磁率計算(解析領域の右側) ※Impedance matching条件から計算
			sigmaM_x[i] = sigmaE_x[i] * (PerM0 / PerE0);													// PML領域右側における仮想的な導磁率計算(解析領域の右側) ※Impedance matching条件から計算
		}

		else
		{
			sigmaE_x[i] = 0.0;																				// PML領域外(媒質(SiおよびSiO2)領域など)における導電率は, 電流源が存在しない自由空間を想定のため, ここでは"0.0"と設定
			sigmaM_x[i] = 0.0;																				// PML領域外(媒質(SiおよびSiO2)領域など)における仮想的な導磁率は, 磁流源が存在しない自由空間を想定のため, ここでは"0.0"と設定
		}
	}

	for (int j = 0; j < Ny + 1; j++)																		// y軸方向におけるPML領域の導電率 および 仮想的な導磁率を設定
	{
		if (j < Ly_PML)
		{
			sigmaE_y[j] = sigmaY_max * pow(1.0 - (j * dy) / dy_PML, M);										// PML領域下側における導電率計算(解析領域の下側)
			//sigmaM_y[j] = sigmaE_y[j] * (PerMSi / PerESi);													// PML領域下側における仮想的な導磁率計算(解析領域の下側) ※Impedance matching条件から計算
			sigmaM_y[j] = sigmaE_y[j] * (PerM0 / PerE0);													// PML領域下側における仮想的な導磁率計算(解析領域の下側) ※Impedance matching条件から計算
		}

		else if (j > Ny - Ly_PML)
		{
			sigmaE_y[j] = sigmaY_max * pow((j * dy - (Ny - Ly_PML) * dy) / dy_PML, M);						// PML領域上側における導電率計算(解析領域の上側)
			//sigmaM_y[j] = sigmaE_y[j] * (PerMSi / PerESi);													// PML領域上側における仮想的な導磁率計算(解析領域の上側) ※Impedance matching条件から計算
			sigmaM_y[j] = sigmaE_y[j] * (PerM0 / PerE0);													// PML領域上側における仮想的な導磁率計算(解析領域の上側) ※Impedance matching条件から計算
		}

		else
		{
			sigmaE_y[j] = 0.0;																				// PML領域外(媒質(SiおよびSiO2)領域など)における導電率は, 電流源が存在しない自由空間を想定のため, ここでは"0.0"と設定
			sigmaM_y[j] = 0.0;																				// PML領域外(媒質(SiおよびSiO2)領域など)における仮想的な導磁率は, 磁流源が存在しない自由空間を想定のため, ここでは"0.0"と設定
		}
	}




	//========================================================================================================================================================================
	//(4). FDTD法による時間差分 および 空間差分における係数の設定と計算

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 係数の設定
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	double** Ae_x = NULL;																					// 時間差分における電場計算用の係数のためのポインタ変数(x成分)
	double** Ae_y = NULL;																					// 時間差分における電場計算用の係数のためのポインタ変数(y成分)
	double** Be_x = NULL;																					// 空間差分における電場計算用の係数のためのポインタ変数(x成分)
	double** Be_y = NULL;																					// 空間差分における電場計算用の係数のためのポインタ変数(y成分)
	Ae_x = (double**)malloc(sizeof(double*) * (Nx + 1));
	Ae_y = (double**)malloc(sizeof(double*) * (Nx + 1));
	Be_x = (double**)malloc(sizeof(double*) * (Nx + 1));
	Be_y = (double**)malloc(sizeof(double*) * (Nx + 1));
	if (Ae_x == NULL)	exit(0);
	if (Ae_y == NULL)	exit(0);
	if (Be_x == NULL)	exit(0);
	if (Be_y == NULL)	exit(0);

	double** Am_x = NULL;																					// 時間差分における磁場計算用の係数のためのポインタ変数(x成分)
	double** Am_y = NULL;																					// 時間差分における磁場計算用の係数のためのポインタ変数(y成分)
	double** Bm_x = NULL;																					// 空間差分における磁場計算用の係数のためのポインタ変数(x成分)
	double** Bm_y = NULL;																					// 空間差分における磁場計算用の係数のためのポインタ変数(y成分)
	Am_x = (double**)malloc(sizeof(double*) * (Nx + 1));
	Am_y = (double**)malloc(sizeof(double*) * (Nx + 1));
	Bm_x = (double**)malloc(sizeof(double*) * (Nx + 1));
	Bm_y = (double**)malloc(sizeof(double*) * (Nx + 1));
	if (Am_x == NULL)		exit(0);
	if (Am_y == NULL)		exit(0);
	if (Bm_x == NULL)		exit(0);
	if (Bm_y == NULL)		exit(0);

	for (int i = 0; i < Nx + 1; i++)
	{
		Ae_x[i] = (double*)malloc(sizeof(double) * (Ny + 1));
		Ae_y[i] = (double*)malloc(sizeof(double) * (Ny + 1));
		Be_x[i] = (double*)malloc(sizeof(double) * (Ny + 1));
		Be_y[i] = (double*)malloc(sizeof(double) * (Ny + 1));

		Am_x[i] = (double*)malloc(sizeof(double) * (Ny + 1));
		Am_y[i] = (double*)malloc(sizeof(double) * (Ny + 1));
		Bm_x[i] = (double*)malloc(sizeof(double) * (Ny + 1));
		Bm_y[i] = (double*)malloc(sizeof(double) * (Ny + 1));
	}


	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 係数の計算
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	for (int i = 0; i < Nx + 1; i++)
	{
		for (int j = 0; j < Ny + 1; j++)
		{
			Ae_x[i][j] = (1.0 - (sigmaE_x[i] * dt) / (2.0 * PerE[i][j])) / (1.0 + (sigmaE_x[i] * dt) / (2.0 * PerE[i][j]));
			Ae_y[i][j] = (1.0 - (sigmaE_y[j] * dt) / (2.0 * PerE[i][j])) / (1.0 + (sigmaE_y[j] * dt) / (2.0 * PerE[i][j]));
			Be_x[i][j] = (dt / PerE[i][j]) / (1.0 + (sigmaE_x[i] * dt) / (2.0 * PerE[i][j]));
			Be_y[i][j] = (dt / PerE[i][j]) / (1.0 + (sigmaE_y[j] * dt) / (2.0 * PerE[i][j]));

			Am_x[i][j] = (1.0 - (sigmaM_x[i] * dt) / (2.0 * PerM[i][j])) / (1.0 + (sigmaM_x[i] * dt) / (2.0 * PerM[i][j]));
			Am_y[i][j] = (1.0 - (sigmaM_y[j] * dt) / (2.0 * PerM[i][j])) / (1.0 + (sigmaM_y[j] * dt) / (2.0 * PerM[i][j]));
			Bm_x[i][j] = (dt / PerM[i][j]) / (1.0 + (sigmaM_x[i] * dt) / (2.0 * PerM[i][j]));
			Bm_y[i][j] = (dt / PerM[i][j]) / (1.0 + (sigmaM_y[j] * dt) / (2.0 * PerM[i][j]));
		}
	}




	//========================================================================================================================================================================
	//(5). FDTD法による数値計算(電磁場解析)

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 電磁場計算用ポインタ変数の設定
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	double** Ez_x = NULL;																					// TM modeにおける電場計算用ポインタ変数(x成分)
	double** Ez_y = NULL;																					// TM modeにおける電場計算用ポインタ変数(y成分)
	double** Ez = NULL;																						// TM modeにおける電場計算用ポインタ変数 ※"Ez_x"と"Ez_y"の和
	double** Hx = NULL;																						// 磁場計算用ポインタ変数(x成分)
	double** Hy = NULL;																						// 磁場計算用ポインタ変数(y成分)
	Ez_x = (double**)malloc(sizeof(double*) * (Nx + 1));													// x成分の電場計算用ポインタ変数(2次元配列)について1つ目の配列要素数を設定(x軸方向用の配列要素)
	Ez_y = (double**)malloc(sizeof(double*) * (Nx + 1));													// y成分の電場計算用ポインタ変数(2次元配列)について1つ目の配列要素数を設定(x軸方向用の配列要素)
	Ez = (double**)malloc(sizeof(double*) * (Nx + 1));														// TM modeにおける電場計算用ポインタ変数(2次元配列)について1つ目の配列要素数を設定(x軸方向用の配列要素)
	Hx = (double**)malloc(sizeof(double*) * (Nx + 1));														// x成分の磁場計算用ポインタ変数(2次元配列)について1つ目の配列要素数を設定(x軸方向用の配列要素)
	Hy = (double**)malloc(sizeof(double*) * (Nx + 1));														// y成分の磁場計算用ポインタ変数(2次元配列)について1つ目の配列要素数を設定(x軸方向用の配列要素)
	if (Ez_x == NULL)	exit(0);
	if (Ez_y == NULL)	exit(0);
	if (Ez == NULL)		exit(0);
	if (Hx == NULL)		exit(0);
	if (Hy == NULL)		exit(0);

	for (int i = 0; i < Nx + 1; i++)
	{
		Ez_x[i] = (double*)malloc(sizeof(double) * (Ny + 1));												// x成分の電場計算用ポインタ変数(2次元配列)について2つ目の配列要素数を設定(y軸方向用の配列要素)
		Ez_y[i] = (double*)malloc(sizeof(double) * (Ny + 1));												// y成分の電場計算用ポインタ変数(2次元配列)について2つ目の配列要素数を設定(y軸方向用の配列要素)
		Ez[i] = (double*)malloc(sizeof(double) * (Ny + 1));													// TM modeにおける電場計算用ポインタ変数(2次元配列)について2つ目の配列要素数を設定(y軸方向用の配列要素)
		Hx[i] = (double*)malloc(sizeof(double) * (Ny + 1));													// x成分の磁場計算用ポインタ変数(2次元配列)について2つ目の配列要素数を設定(y軸方向用の配列要素)
		Hy[i] = (double*)malloc(sizeof(double) * (Ny + 1));													// x成分の磁場計算用ポインタ変数(2次元配列)について2つ目の配列要素数を設定(y軸方向用の配列要素)
	}
	if (Ez_x == NULL)	exit(0);
	if (Ez_y == NULL)	exit(0);
	if (Ez == NULL)		exit(0);
	if (Hx == NULL)		exit(0);
	if (Hy == NULL)		exit(0);


	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 電磁場の初期値設定
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	for (int i = 0; i < Nx + 1; i++)
	{
		for (int j = 0; j < Ny + 1; j++)
		{
			Ez_x[i][j] = 0.0;
			Ez_y[i][j] = 0.0;
			Ez[i][j] = 0.0;
			Hx[i][j] = 0.0;
			Hy[i][j] = 0.0;
		}
	}


	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Appendix. 数値計算結果のData File生成のための設定
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	FILE* file_a = NULL;
	FILE* file_b = NULL;
	FILE* file_c = NULL;
	FILE* file_d = NULL;
	FILE* file_e = NULL;
	FILE* file_f = NULL;
	FILE* file_g = NULL;
	FILE* file_h = NULL;
	FILE* file_i = NULL;
	FILE* file_j = NULL;
	FILE* file_k = NULL;
	FILE* file_l = NULL;
	FILE* file_m = NULL;
	FILE* file_n = NULL;
	FILE* file_o = NULL;
	FILE* file_p = NULL;
	FILE* file_q = NULL;
	FILE* file_r = NULL;
	FILE* file_s = NULL;
	FILE* file_t = NULL;
	FILE* file_u = NULL;
	//FILE* file_v = NULL;
	//FILE* file_w = NULL;
	//FILE* file_x = NULL;
	//FILE* file_y = NULL;
	//FILE* file_z = NULL;


	file_a = fopen("E1_0fs_withWG_NORXNORNAND00.txt", "w");
	file_b = fopen("E2_5fs_withWG_NORXNORNAND00.txt", "w");
	file_c = fopen("E5_0fs_withWG_NORXNORNAND00.txt", "w");
	file_d = fopen("E7_5fs_withWG_NORXNORNAND00.txt", "w");
	file_e = fopen("E10_0fs_withWG_NORXNORNAND00.txt", "w");
	file_f = fopen("E12_5fs_withWG_NORXNORNAND00.txt", "w");
	file_g = fopen("E15_0fs_withWG_NORXNORNAND00.txt", "w");
	file_h = fopen("E17_5fs_withWG_NORXNORNAND00.txt", "w");
	file_i = fopen("E20_0fs_withWG_NORXNORNAND00.txt", "w");
	file_j = fopen("E22_5fs_withWG_NORXNORNAND00.txt", "w");
	file_k = fopen("E25_0fs_withWG_NORXNORNAND00.txt", "w");
	file_l = fopen("E27_5fs_withWG_NORXNORNAND00.txt", "w");
	file_m = fopen("E30_0fs_withWG_NORXNORNAND00.txt", "w");
	file_n = fopen("E32_5fs_withWG_NORXNORNAND00.txt", "w");
	file_o = fopen("E35_0fs_withWG_NORXNORNAND00.txt", "w");
	file_p = fopen("E37_5fs_withWG_NORXNORNAND00.txt", "w");
	file_q = fopen("E40_0fs_withWG_NORXNORNAND00.txt", "w");
	file_r = fopen("E42_5fs_withWG_NORXNORNAND00.txt", "w");
	file_s = fopen("E45_0fs_withWG_NORXNORNAND00.txt", "w");
	file_t = fopen("E47_5fs_withWG_NORXNORNAND00.txt", "w");
	file_u = fopen("E50_0fs_withWG_NORXNORNAND00.txt", "w");
	//FILE* file_v = fopen("Exxxfs_withWG_NORXNORNANDxx.txt", "w");
	//FILE* file_w = fopen("Exxxfs_withWG_NORXNORNANDxx.txt", "w");
	//FILE* file_x = fopen("Exxxfs_withWG_NORXNORNANDxx.txt", "w");
	//FILE* file_y = fopen("Exxxfs_withWG_NORXNORNANDxx.txt", "w");
	//FILE* file_z = fopen("Exxxfs_withWG_NORXNORNANDxx.txt", "w");


	if (file_a == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_b == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_c == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_d == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_e == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_f == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_g == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_h == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_i == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_j == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_k == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_l == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_m == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_n == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_o == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_p == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_q == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_r == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_s == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_t == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	if (file_u == NULL)
	{
		printf("Error: can't open file\n");
		return 1;
	}
	//if (file_v == NULL)
	//{
	//	printf("Error: can't open file\n");
	//	return 1;
	//}
	//if (file_w == NULL)
	//{
	//	printf("Error: can't open file\n");
	//	return 1;
	//}
	//if (file_x == NULL)
	//{
	//	printf("Error: can't open file\n");
	//	return 1;
	//}
	//if (file_y == NULL)
	//{
	//	printf("Error: can't open file\n");
	//	return 1;
	//}
	//if (file_z == NULL)
	//{
	//	printf("Error: can't open file\n");
	//	return 1;
	//}




	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 2次元pulse波形(2次元確率分布関数 = 2次元Gauss分布)を表現するための設定
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//double a = 4.4 * pow(10.0, -14.0);																		// x成分の分散
	double a = 1.0;																							// x成分の分散
	double b = 1.0;																							// y成分の分散


	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 電磁場数値計算のための時間stepにおけるLoop処理
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	for (int t = 0; t < (3 * Nt) + 1; t++)
	{
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Gaussian Modulated Continuous Waveの電場導入 ※円形波
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Ez[80][350] = 1.0 * exp(-(1.0 / 2.0) * (pow((t * dt) / a, 2.0))) * cos(w0 * t * dt);
		//Ez[50][320] = 1.0 * exp(-(1.0 / 2.0) * (pow((t * dt) / a, 2.0))) * cos(w0 * t * dt);

		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Gaussian Modulated Continuous Waveの電場導入 ※平面波(1)
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//for (int j = 330; j < 370 + 1; j++)
		//{
		//	Ez[50][j] = 1.0 * exp(-(1.0 / 2.0) * (pow((t * dt) / a, 2.0))) * cos(w0 * t * dt);
		//}
		//for (int j = 360; j < 400 + 1; j++)
		//{
		//	Ez[50][j] = 1.0 * exp(-(1.0 / 2.0) * (pow((t * dt) / a, 2.0))) * cos(w0 * t * dt);
		//}
		//for (int j = Ly_PML; j < Ny - Ly_PML + 1; j++)
		//{
		//	Ez[50][j] = 1.0 * exp(-(1.0 / 2.0) * (pow((t * dt) / a, 2.0))) * cos(w0 * t * dt);
		//}


		//for (int j = 300; j < 340 + 1; j++)
		//{
		//	Ez[50][j] = 1.0 * exp(-(1.0 / 2.0) * (pow((t * dt) / a, 2.0))) * cos(w0 * t * dt);
		//}

		//for (int j = Ly_PML; j < Ny - Ly_PML + 1; j++)
		//{
		//	Ez[50][j] = 1.0 * exp(-(1.0 / 2.0) * (pow((t * dt) / a, 2.0))) * cos(w0 * t * dt);
		//}

		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Gaussian Modulated Continuous Waveの電場導入 ※平面波(2)
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		for (int j = 300; j < 340; j++)																		// Input signal
		{
			Ez[50][j] = 1.0 * exp(-(1.0 / 2.0) * (pow((t * dt) / a, 2.0))) * cos(w0 * t * dt);
		}

		//for (int i = 300; i < 340; i++)																		// Reference signal; phase difference 0
		//{
		//	Ez[i][50] = 1.0 * exp(-(1.0 / 2.0) * (pow((t * dt) / a, 2.0))) * cos(w0 * t * dt);
		//}
		//for (int i = 300; i < 340; i++)																		// Reference signal; phase difference pi
		//{
		//	Ez[i][50] = 1.0 * exp(-(1.0 / 2.0) * (pow((t * dt) / a, 2.0))) * cos(w0 * t * dt - M_PI);
		//}


		//for (int j = 300; j < 340 + 1; j++)
		//{
		//	Ez[50][j] = 1.0 * exp(-(1.0 / 2.0) * (pow((t * dt) / a, 2.0))) * cos(w0 * t * dt);
		//}

		//for (int i = 300; i < 340 + 1; i++)
		//{
		//	Ez[i][50] = 1.0 * exp(-(1.0 / 2.0) * (pow((t * dt) / a, 2.0))) * cos(w0 * t * dt);
		//}

		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// 場(電磁場)の更新
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// ■ 磁場の更新(ループ計算)
		for (int i = 0; i < Nx; i++)
		{
			for (int j = 0; j < Ny; j++)
			{
				Hx[i][j] = Am_y[i][j] * Hx[i][j] - (Bm_y[i][j] / dy) * (Ez[i][j + 1] - Ez[i][j]);			// 
				Hy[i][j] = Am_x[i][j] * Hy[i][j] + (Bm_x[i][j] / dx) * (Ez[i + 1][j] - Ez[i][j]);			// 
			}
		}

		// ■ 電場の更新(ループ計算)
		for (int i = 1; i < Nx + 1; i++)
		{
			for (int j = 1; j < Ny + 1; j++)
			{
				Ez_x[i][j] = Ae_x[i][j] * Ez_x[i][j] + (Be_x[i][j] / dx) * (Hy[i][j] - Hy[i - 1][j]);		// 
				Ez_y[i][j] = Ae_y[i][j] * Ez_y[i][j] - (Be_y[i][j] / dy) * (Hx[i][j] - Hx[i][j - 1]);		// 
				Ez[i][j] = Ez_x[i][j] + Ez_y[i][j];															// 
			}
		}


		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Appendix. 数値計算結果のData File生成
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		if (t == 100)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_a, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_a, "\n");
			}
			fprintf(file_a, "\n");
		}

		if (t == 250)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_b, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_b, "\n");
			}
			fprintf(file_b, "\n");
		}

		if (t == 500)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_c, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_c, "\n");
			}
			fprintf(file_c, "\n");
		}

		if (t == 750)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_d, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_d, "\n");
			}
			fprintf(file_d, "\n");
		}

		if (t == 1000)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_e, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_e, "\n");
			}
			fprintf(file_e, "\n");
		}

		if (t == 1250)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_f, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_f, "\n");
			}
			fprintf(file_f, "\n");
		}

		if (t == 1500)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_g, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_g, "\n");
			}
			fprintf(file_g, "\n");
		}

		if (t == 1750)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_h, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_h, "\n");
			}
			fprintf(file_h, "\n");
		}

		if (t == 2000)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_i, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_i, "\n");
			}
			fprintf(file_i, "\n");
		}

		if (t == 2250)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_j, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_j, "\n");
			}
			fprintf(file_j, "\n");
		}

		if (t == 2500)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_k, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_k, "\n");
			}
			fprintf(file_k, "\n");
		}

		if (t == 2750)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_l, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_l, "\n");
			}
			fprintf(file_l, "\n");
		}

		if (t == 3000)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_m, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_m, "\n");
			}
			fprintf(file_m, "\n");
		}

		if (t == 3250)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_n, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_n, "\n");
			}
			fprintf(file_n, "\n");
		}

		if (t == 3500)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_o, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_o, "\n");
			}
			fprintf(file_o, "\n");
		}

		if (t == 3750)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_p, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_p, "\n");
			}
			fprintf(file_p, "\n");
		}

		if (t == 4000)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_q, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_q, "\n");
			}
			fprintf(file_q, "\n");
		}

		if (t == 4250)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_r, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_r, "\n");
			}
			fprintf(file_r, "\n");
		}

		if (t == 4500)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_s, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_s, "\n");
			}
			fprintf(file_s, "\n");
		}

		if (t == 4750)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_t, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_t, "\n");
			}
			fprintf(file_t, "\n");
		}

		if (t == 5000)
		{
			for (int i = 50; i < Nx - Lx_PML + 1; i++)
			{
				for (int j = 50; j < Ny - Ly_PML + 1; j++)
				{
					fprintf(file_u, "%.3f\t%.3f\t%f\n", (i - 50) * dx * pow(10.0, 6.0), (j - 50) * dy * pow(10.0, 6.0), Ez[i][j]);
				}
				fprintf(file_u, "\n");
			}
			fprintf(file_u, "\n");
		}

	}

	fclose(file_a);
	fclose(file_b);
	fclose(file_c);
	fclose(file_d);
	fclose(file_e);
	fclose(file_f);
	fclose(file_g);
	fclose(file_h);
	fclose(file_i);
	fclose(file_j);
	fclose(file_k);
	fclose(file_l);
	fclose(file_m);
	fclose(file_n);
	fclose(file_o);
	fclose(file_p);
	fclose(file_q);
	fclose(file_r);
	fclose(file_s);
	fclose(file_t);
	fclose(file_u);
	//fclose(file_v);
	//fclose(file_w);
	//fclose(file_x);
	//fclose(file_y);
	//fclose(file_z);




	//========================================================================================================================================================================
	//(Appendix). ポインタ変数のmemory解放 

	for (int j = 0; j < Ny + 1; j++)
	{
		free(PerE[j]);
		free(PerM[j]);
		free(r[j]);
		//free(SigmaE[j]);
		//free(SigmaM[j]);
		free(Ae_x[j]);
		free(Ae_y[j]);
		free(Am_x[j]);
		free(Am_y[j]);
		free(Be_x[j]);
		free(Be_y[j]);
		free(Bm_x[j]);
		free(Bm_y[j]);
		//free(Ae[j]);
		//free(Be[j]);
		free(Ez_x[j]);
		free(Ez_y[j]);
		free(Ez[j]);
		free(Hx[j]);
		free(Hy[j]);
	}

	free(PerE);
	free(PerM);
	free(r);
	//free(SigmaE);
	//free(SigmaM);
	free(Ae_x);
	free(Ae_y);
	free(Am_x);
	free(Am_y);
	free(Be_x);
	free(Be_y);
	free(Bm_x);
	free(Bm_y);
	//free(Ae);
	//free(Be);
	free(Ez_x);
	free(Ez_y);
	free(Ez);
	free(Hx);
	free(Hy);

	free(sigmaE_x);
	free(sigmaE_y);
	free(sigmaM_x);
	free(sigmaM_y);

	//free(angle);
	//free(r);
	//free(rx);
	//free(ry);


	return 0;
}